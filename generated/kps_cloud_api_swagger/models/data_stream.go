// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataStream DataStream is object model for data stream
//
// DataStreams are fundamental building blocks for Karbon Platform Services data pipeline.
// swagger:model DataStream
type DataStream struct {

	// AWS region. Required if cloudType == AWS
	// Enum: [us-east-2 us-east-1 us-west-1 us-west-2 ap-northeast-1 ap-northeast-2 ap-northeast-3 ap-south-1 ap-southeast-1 ap-southeast-2 ca-central-1 cn-north-1 cn-northwest-1 eu-central-1 eu-west-1 eu-west-2 eu-west-3 sa-east-1]
	AWSCloudRegion string `json:"awsCloudRegion,omitempty"`

	// Type of the DataStream at AWS Cloud.
	// Required if cloudType == AWS
	// Enum: [Kinesis SQS S3 DynamoDB]
	AWSStreamType string `json:"awsStreamType,omitempty"`

	// Type of the DataStream at Azure Cloud.
	// Required if cloudType == Azure
	// Enum: [Blob]
	AZStreamType string `json:"azStreamType,omitempty"`

	// CloudCreds id.
	// Required if destination == Cloud
	CloudCredsID string `json:"cloudCredsId,omitempty"`

	// Cloud type, required if destination == Cloud
	// Enum: [AWS GCP Azure]
	CloudType string `json:"cloudType,omitempty"`

	// ntnx:ignore
	// timestamp feature supported by DB
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// Data Ifc endpoints connected to this datastream
	DataIfcEndpoints []*DataIfcEndpoint `json:"DataIfcEndpoints"`

	// Retention policy for this DataStream.
	// Multiple RetentionInfo are combined using AND semantics.
	// For example, retain data for 1 month AND up to 2 TB of data.
	// Required: true
	DataRetention []*RetentionInfo `json:"dataRetention"`

	// Data type of the DataStream.
	// For example, Temperature, Pressure, Image, Multiple, etc.
	// Required: true
	DataType *string `json:"dataType"`

	// The description of the DataStream
	Description string `json:"description,omitempty"`

	// Destination of the DataStream.
	// Either Edge or Cloud or DataInterface.
	// Required: true
	// Enum: [Edge Cloud DataInterface]
	Destination *string `json:"destination"`

	// Type of the DataStream at Edge.
	// Required if destination == Edge
	// Enum: [Kafka ElasticSearch MQTT DataDriver None]
	EdgeStreamType string `json:"edgeStreamType,omitempty"`

	// Whether to turn sampling on.
	// If true, then samplingInterval should be set as well.
	// Required: true
	EnableSampling *bool `json:"enableSampling"`

	// End point of datastream.
	// User specifies the endpoint.
	EndPoint string `json:"endPoint,omitempty"`

	// Endpoint URI
	// Derived from existing fields
	// required false
	EndPointURI string `json:"endPointURI,omitempty"`

	// GCP region. Required if cloudType == GCP
	// Enum: [northamerica-northeast1 us-central1 us-west1 us-east4 us-east1 southamerica-east1 europe-west1 europe-west2 europe-west3 europe-west4 asia-south1 asia-southeast1 asia-east1 asia-northeast1 australia-southeast1]
	GCPCloudRegion string `json:"gcpCloudRegion,omitempty"`

	// Type of the DataStream at GCP Cloud.
	// Required if cloudType == GCP
	// Enum: [PubSub CloudDatastore CloudSQL CloudStorage]
	GCPStreamType string `json:"gcpStreamType,omitempty"`

	// ID of the entity
	// Maximum character length is 64 for project, category, and runtime environment,
	// 36 for other entity types.
	ID string `json:"id,omitempty"`

	// Name of the DataStream.
	// This is the published output (Kafka topic) name.
	// Required: true
	Name *string `json:"name"`

	// The origin of the DataStream.
	// Either 'Data Source' or 'Data Stream'
	// Required: true
	// Enum: [Data Source Data Stream]
	Origin *string `json:"origin"`

	// If origin == 'Data Stream', then originId
	// can be used in place of originSelectors
	// to specify the origin data stream ID if the origin data stream is unique.
	OriginID string `json:"originId,omitempty"`

	// A list of CategoryInfo used as criteria
	// to filter sources applicable to this DataStream.
	// Required: true
	OriginSelectors []*CategoryInfo `json:"originSelectors"`

	// ID of parent project.
	// This should be required, but is not marked as such due to backward compatibility.
	ProjectID string `json:"projectId,omitempty"`

	// Sampling interval in seconds.
	// The sampling interval applies to each mqtt/kafka topic separately.
	SamplingInterval float64 `json:"samplingInterval,omitempty"`

	// Current size of the DataStream output in GB.
	// Required: true
	Size *float64 `json:"size"`

	// State of this entity
	State string `json:"state,omitempty"`

	// ntnx:ignore
	// Required: true
	TenantID *string `json:"tenantId"`

	// List of transformations (together with their args)
	// to apply to the origin data
	// to produce the destination data.
	// Could be empty if no transformation required.
	// Each entry is the id of the transformation Script to apply to input from origin
	// to produce output to destination.
	// Required: true
	TransformationArgsList []*TransformationArgs `json:"transformationArgsList"`

	// ntnx:ignore
	// timestamp feature supported by DB
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`

	// ntnx:ignore
	// Version of entity, implemented using timestamp in nano seconds
	// This is set to float64 since JSON numbers are floating point
	// May lose precision due to truncation but should have milli-second precision
	Version float64 `json:"version,omitempty"`

	// out data ifc
	OutDataIfc *DataSource `json:"outDataIfc,omitempty"`
}

// Validate validates this data stream
func (m *DataStream) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAWSCloudRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAWSStreamType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAZStreamType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataIfcEndpoints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataRetention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdgeStreamType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnableSampling(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGCPCloudRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGCPStreamType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginSelectors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransformationArgsList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutDataIfc(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataStreamTypeAWSCloudRegionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["us-east-2","us-east-1","us-west-1","us-west-2","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ca-central-1","cn-north-1","cn-northwest-1","eu-central-1","eu-west-1","eu-west-2","eu-west-3","sa-east-1"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeAWSCloudRegionPropEnum = append(dataStreamTypeAWSCloudRegionPropEnum, v)
	}
}

const (

	// DataStreamAWSCloudRegionUsEast2 captures enum value "us-east-2"
	DataStreamAWSCloudRegionUsEast2 string = "us-east-2"

	// DataStreamAWSCloudRegionUsEast1 captures enum value "us-east-1"
	DataStreamAWSCloudRegionUsEast1 string = "us-east-1"

	// DataStreamAWSCloudRegionUsWest1 captures enum value "us-west-1"
	DataStreamAWSCloudRegionUsWest1 string = "us-west-1"

	// DataStreamAWSCloudRegionUsWest2 captures enum value "us-west-2"
	DataStreamAWSCloudRegionUsWest2 string = "us-west-2"

	// DataStreamAWSCloudRegionApNortheast1 captures enum value "ap-northeast-1"
	DataStreamAWSCloudRegionApNortheast1 string = "ap-northeast-1"

	// DataStreamAWSCloudRegionApNortheast2 captures enum value "ap-northeast-2"
	DataStreamAWSCloudRegionApNortheast2 string = "ap-northeast-2"

	// DataStreamAWSCloudRegionApNortheast3 captures enum value "ap-northeast-3"
	DataStreamAWSCloudRegionApNortheast3 string = "ap-northeast-3"

	// DataStreamAWSCloudRegionApSouth1 captures enum value "ap-south-1"
	DataStreamAWSCloudRegionApSouth1 string = "ap-south-1"

	// DataStreamAWSCloudRegionApSoutheast1 captures enum value "ap-southeast-1"
	DataStreamAWSCloudRegionApSoutheast1 string = "ap-southeast-1"

	// DataStreamAWSCloudRegionApSoutheast2 captures enum value "ap-southeast-2"
	DataStreamAWSCloudRegionApSoutheast2 string = "ap-southeast-2"

	// DataStreamAWSCloudRegionCaCentral1 captures enum value "ca-central-1"
	DataStreamAWSCloudRegionCaCentral1 string = "ca-central-1"

	// DataStreamAWSCloudRegionCnNorth1 captures enum value "cn-north-1"
	DataStreamAWSCloudRegionCnNorth1 string = "cn-north-1"

	// DataStreamAWSCloudRegionCnNorthwest1 captures enum value "cn-northwest-1"
	DataStreamAWSCloudRegionCnNorthwest1 string = "cn-northwest-1"

	// DataStreamAWSCloudRegionEuCentral1 captures enum value "eu-central-1"
	DataStreamAWSCloudRegionEuCentral1 string = "eu-central-1"

	// DataStreamAWSCloudRegionEuWest1 captures enum value "eu-west-1"
	DataStreamAWSCloudRegionEuWest1 string = "eu-west-1"

	// DataStreamAWSCloudRegionEuWest2 captures enum value "eu-west-2"
	DataStreamAWSCloudRegionEuWest2 string = "eu-west-2"

	// DataStreamAWSCloudRegionEuWest3 captures enum value "eu-west-3"
	DataStreamAWSCloudRegionEuWest3 string = "eu-west-3"

	// DataStreamAWSCloudRegionSaEast1 captures enum value "sa-east-1"
	DataStreamAWSCloudRegionSaEast1 string = "sa-east-1"
)

// prop value enum
func (m *DataStream) validateAWSCloudRegionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeAWSCloudRegionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateAWSCloudRegion(formats strfmt.Registry) error {

	if swag.IsZero(m.AWSCloudRegion) { // not required
		return nil
	}

	// value enum
	if err := m.validateAWSCloudRegionEnum("awsCloudRegion", "body", m.AWSCloudRegion); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeAWSStreamTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Kinesis","SQS","S3","DynamoDB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeAWSStreamTypePropEnum = append(dataStreamTypeAWSStreamTypePropEnum, v)
	}
}

const (

	// DataStreamAWSStreamTypeKinesis captures enum value "Kinesis"
	DataStreamAWSStreamTypeKinesis string = "Kinesis"

	// DataStreamAWSStreamTypeSQS captures enum value "SQS"
	DataStreamAWSStreamTypeSQS string = "SQS"

	// DataStreamAWSStreamTypeS3 captures enum value "S3"
	DataStreamAWSStreamTypeS3 string = "S3"

	// DataStreamAWSStreamTypeDynamoDB captures enum value "DynamoDB"
	DataStreamAWSStreamTypeDynamoDB string = "DynamoDB"
)

// prop value enum
func (m *DataStream) validateAWSStreamTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeAWSStreamTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateAWSStreamType(formats strfmt.Registry) error {

	if swag.IsZero(m.AWSStreamType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAWSStreamTypeEnum("awsStreamType", "body", m.AWSStreamType); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeAZStreamTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Blob"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeAZStreamTypePropEnum = append(dataStreamTypeAZStreamTypePropEnum, v)
	}
}

const (

	// DataStreamAZStreamTypeBlob captures enum value "Blob"
	DataStreamAZStreamTypeBlob string = "Blob"
)

// prop value enum
func (m *DataStream) validateAZStreamTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeAZStreamTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateAZStreamType(formats strfmt.Registry) error {

	if swag.IsZero(m.AZStreamType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAZStreamTypeEnum("azStreamType", "body", m.AZStreamType); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeCloudTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AWS","GCP","Azure"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeCloudTypePropEnum = append(dataStreamTypeCloudTypePropEnum, v)
	}
}

const (

	// DataStreamCloudTypeAWS captures enum value "AWS"
	DataStreamCloudTypeAWS string = "AWS"

	// DataStreamCloudTypeGCP captures enum value "GCP"
	DataStreamCloudTypeGCP string = "GCP"

	// DataStreamCloudTypeAzure captures enum value "Azure"
	DataStreamCloudTypeAzure string = "Azure"
)

// prop value enum
func (m *DataStream) validateCloudTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeCloudTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateCloudType(formats strfmt.Registry) error {

	if swag.IsZero(m.CloudType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCloudTypeEnum("cloudType", "body", m.CloudType); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateDataIfcEndpoints(formats strfmt.Registry) error {

	if swag.IsZero(m.DataIfcEndpoints) { // not required
		return nil
	}

	for i := 0; i < len(m.DataIfcEndpoints); i++ {
		if swag.IsZero(m.DataIfcEndpoints[i]) { // not required
			continue
		}

		if m.DataIfcEndpoints[i] != nil {
			if err := m.DataIfcEndpoints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("DataIfcEndpoints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataStream) validateDataRetention(formats strfmt.Registry) error {

	if err := validate.Required("dataRetention", "body", m.DataRetention); err != nil {
		return err
	}

	for i := 0; i < len(m.DataRetention); i++ {
		if swag.IsZero(m.DataRetention[i]) { // not required
			continue
		}

		if m.DataRetention[i] != nil {
			if err := m.DataRetention[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dataRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataStream) validateDataType(formats strfmt.Registry) error {

	if err := validate.Required("dataType", "body", m.DataType); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeDestinationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Edge","Cloud","DataInterface"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeDestinationPropEnum = append(dataStreamTypeDestinationPropEnum, v)
	}
}

const (

	// DataStreamDestinationEdge captures enum value "Edge"
	DataStreamDestinationEdge string = "Edge"

	// DataStreamDestinationCloud captures enum value "Cloud"
	DataStreamDestinationCloud string = "Cloud"

	// DataStreamDestinationDataInterface captures enum value "DataInterface"
	DataStreamDestinationDataInterface string = "DataInterface"
)

// prop value enum
func (m *DataStream) validateDestinationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeDestinationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateDestination(formats strfmt.Registry) error {

	if err := validate.Required("destination", "body", m.Destination); err != nil {
		return err
	}

	// value enum
	if err := m.validateDestinationEnum("destination", "body", *m.Destination); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeEdgeStreamTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Kafka","ElasticSearch","MQTT","DataDriver","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeEdgeStreamTypePropEnum = append(dataStreamTypeEdgeStreamTypePropEnum, v)
	}
}

const (

	// DataStreamEdgeStreamTypeKafka captures enum value "Kafka"
	DataStreamEdgeStreamTypeKafka string = "Kafka"

	// DataStreamEdgeStreamTypeElasticSearch captures enum value "ElasticSearch"
	DataStreamEdgeStreamTypeElasticSearch string = "ElasticSearch"

	// DataStreamEdgeStreamTypeMQTT captures enum value "MQTT"
	DataStreamEdgeStreamTypeMQTT string = "MQTT"

	// DataStreamEdgeStreamTypeDataDriver captures enum value "DataDriver"
	DataStreamEdgeStreamTypeDataDriver string = "DataDriver"

	// DataStreamEdgeStreamTypeNone captures enum value "None"
	DataStreamEdgeStreamTypeNone string = "None"
)

// prop value enum
func (m *DataStream) validateEdgeStreamTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeEdgeStreamTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateEdgeStreamType(formats strfmt.Registry) error {

	if swag.IsZero(m.EdgeStreamType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEdgeStreamTypeEnum("edgeStreamType", "body", m.EdgeStreamType); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateEnableSampling(formats strfmt.Registry) error {

	if err := validate.Required("enableSampling", "body", m.EnableSampling); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeGCPCloudRegionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["northamerica-northeast1","us-central1","us-west1","us-east4","us-east1","southamerica-east1","europe-west1","europe-west2","europe-west3","europe-west4","asia-south1","asia-southeast1","asia-east1","asia-northeast1","australia-southeast1"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeGCPCloudRegionPropEnum = append(dataStreamTypeGCPCloudRegionPropEnum, v)
	}
}

const (

	// DataStreamGCPCloudRegionNorthamericaNortheast1 captures enum value "northamerica-northeast1"
	DataStreamGCPCloudRegionNorthamericaNortheast1 string = "northamerica-northeast1"

	// DataStreamGCPCloudRegionUsCentral1 captures enum value "us-central1"
	DataStreamGCPCloudRegionUsCentral1 string = "us-central1"

	// DataStreamGCPCloudRegionUsWest1 captures enum value "us-west1"
	DataStreamGCPCloudRegionUsWest1 string = "us-west1"

	// DataStreamGCPCloudRegionUsEast4 captures enum value "us-east4"
	DataStreamGCPCloudRegionUsEast4 string = "us-east4"

	// DataStreamGCPCloudRegionUsEast1 captures enum value "us-east1"
	DataStreamGCPCloudRegionUsEast1 string = "us-east1"

	// DataStreamGCPCloudRegionSouthamericaEast1 captures enum value "southamerica-east1"
	DataStreamGCPCloudRegionSouthamericaEast1 string = "southamerica-east1"

	// DataStreamGCPCloudRegionEuropeWest1 captures enum value "europe-west1"
	DataStreamGCPCloudRegionEuropeWest1 string = "europe-west1"

	// DataStreamGCPCloudRegionEuropeWest2 captures enum value "europe-west2"
	DataStreamGCPCloudRegionEuropeWest2 string = "europe-west2"

	// DataStreamGCPCloudRegionEuropeWest3 captures enum value "europe-west3"
	DataStreamGCPCloudRegionEuropeWest3 string = "europe-west3"

	// DataStreamGCPCloudRegionEuropeWest4 captures enum value "europe-west4"
	DataStreamGCPCloudRegionEuropeWest4 string = "europe-west4"

	// DataStreamGCPCloudRegionAsiaSouth1 captures enum value "asia-south1"
	DataStreamGCPCloudRegionAsiaSouth1 string = "asia-south1"

	// DataStreamGCPCloudRegionAsiaSoutheast1 captures enum value "asia-southeast1"
	DataStreamGCPCloudRegionAsiaSoutheast1 string = "asia-southeast1"

	// DataStreamGCPCloudRegionAsiaEast1 captures enum value "asia-east1"
	DataStreamGCPCloudRegionAsiaEast1 string = "asia-east1"

	// DataStreamGCPCloudRegionAsiaNortheast1 captures enum value "asia-northeast1"
	DataStreamGCPCloudRegionAsiaNortheast1 string = "asia-northeast1"

	// DataStreamGCPCloudRegionAustraliaSoutheast1 captures enum value "australia-southeast1"
	DataStreamGCPCloudRegionAustraliaSoutheast1 string = "australia-southeast1"
)

// prop value enum
func (m *DataStream) validateGCPCloudRegionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeGCPCloudRegionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateGCPCloudRegion(formats strfmt.Registry) error {

	if swag.IsZero(m.GCPCloudRegion) { // not required
		return nil
	}

	// value enum
	if err := m.validateGCPCloudRegionEnum("gcpCloudRegion", "body", m.GCPCloudRegion); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeGCPStreamTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PubSub","CloudDatastore","CloudSQL","CloudStorage"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeGCPStreamTypePropEnum = append(dataStreamTypeGCPStreamTypePropEnum, v)
	}
}

const (

	// DataStreamGCPStreamTypePubSub captures enum value "PubSub"
	DataStreamGCPStreamTypePubSub string = "PubSub"

	// DataStreamGCPStreamTypeCloudDatastore captures enum value "CloudDatastore"
	DataStreamGCPStreamTypeCloudDatastore string = "CloudDatastore"

	// DataStreamGCPStreamTypeCloudSQL captures enum value "CloudSQL"
	DataStreamGCPStreamTypeCloudSQL string = "CloudSQL"

	// DataStreamGCPStreamTypeCloudStorage captures enum value "CloudStorage"
	DataStreamGCPStreamTypeCloudStorage string = "CloudStorage"
)

// prop value enum
func (m *DataStream) validateGCPStreamTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeGCPStreamTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateGCPStreamType(formats strfmt.Registry) error {

	if swag.IsZero(m.GCPStreamType) { // not required
		return nil
	}

	// value enum
	if err := m.validateGCPStreamTypeEnum("gcpStreamType", "body", m.GCPStreamType); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var dataStreamTypeOriginPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Data Source","Data Stream"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataStreamTypeOriginPropEnum = append(dataStreamTypeOriginPropEnum, v)
	}
}

const (

	// DataStreamOriginDataSource captures enum value "Data Source"
	DataStreamOriginDataSource string = "Data Source"

	// DataStreamOriginDataStream captures enum value "Data Stream"
	DataStreamOriginDataStream string = "Data Stream"
)

// prop value enum
func (m *DataStream) validateOriginEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataStreamTypeOriginPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataStream) validateOrigin(formats strfmt.Registry) error {

	if err := validate.Required("origin", "body", m.Origin); err != nil {
		return err
	}

	// value enum
	if err := m.validateOriginEnum("origin", "body", *m.Origin); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateOriginSelectors(formats strfmt.Registry) error {

	if err := validate.Required("originSelectors", "body", m.OriginSelectors); err != nil {
		return err
	}

	for i := 0; i < len(m.OriginSelectors); i++ {
		if swag.IsZero(m.OriginSelectors[i]) { // not required
			continue
		}

		if m.OriginSelectors[i] != nil {
			if err := m.OriginSelectors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originSelectors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataStream) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateTenantID(formats strfmt.Registry) error {

	if err := validate.Required("tenantId", "body", m.TenantID); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateTransformationArgsList(formats strfmt.Registry) error {

	if err := validate.Required("transformationArgsList", "body", m.TransformationArgsList); err != nil {
		return err
	}

	for i := 0; i < len(m.TransformationArgsList); i++ {
		if swag.IsZero(m.TransformationArgsList[i]) { // not required
			continue
		}

		if m.TransformationArgsList[i] != nil {
			if err := m.TransformationArgsList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transformationArgsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataStream) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updatedAt", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DataStream) validateOutDataIfc(formats strfmt.Registry) error {

	if swag.IsZero(m.OutDataIfc) { // not required
		return nil
	}

	if m.OutDataIfc != nil {
		if err := m.OutDataIfc.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outDataIfc")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataStream) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataStream) UnmarshalBinary(b []byte) error {
	var res DataStream
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
